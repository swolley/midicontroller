// Generated by CodiumAI

import { expect } from "vitest";
import { ObjectUtils, StringUtils, Validators, getOffset } from "../classes/Utils";

/*
Code Analysis

Objective:
The objective of the getOffset function is to calculate the offset position of an HTML element relative to its offset parent.

Inputs:
- el: an HTMLElement or null, representing the element whose offset position needs to be calculated.

Flow:
- Initialize _x and _y to 0.
- While el is not null and its offsetLeft and offsetTop are not NaN:
  - Add el's offsetLeft minus its scrollLeft to _x.
  - Add el's offsetTop minus its scrollTop to _y.
  - Set el to its offsetParent.
- Return an object with the calculated top and left values.

Outputs:
- An object with the top and left offset values of the input element.

Additional aspects:
- The function uses the offsetParent property to traverse up the DOM tree and calculate the offset position.
- The function uses the isNaN function to check if the offsetLeft and offsetTop values are valid numbers.
- The function does not take into account any margins or borders of the element or its parent elements.
*/

describe("getOffset_function", () => {
    // Tests that the function returns the correct offset for a valid element.
    it("test_get_offset_with_valid_element", () => {
        // Arrange
        const element = document.createElement("div");
        element.style.position = "absolute";
        element.style.top = "50px";
        element.style.left = "100px";
        document.body.appendChild(element);

        // Act
        const result = getOffset(element);

        // Assert
        expect(result.top).equal(50);
        expect(result.left).equal(100);

        // Clean up
        document.body.removeChild(element);
    });

    // Tests that the function returns {top: 0, left: 0} for a null element.
    it("test_get_offset_with_null_element", () => {
        // Arrange
        const element = null;

        // Act
        const result = getOffset(element);

        // Assert
        expect(result.top).equal(0);
        expect(result.left).equal(0);
    });

    // Tests that the function returns the correct offset for an element with NaN offsetLeft or offsetTop.
    it("test_get_offset_with_element_with_NaN_offsetLeft_or_offsetTop", () => {
        // Arrange
        const element = document.createElement("div");
        element.style.position = "absolute";
        element.style.top = "50px";
        element.style.left = "invalid";
        document.body.appendChild(element);

        // Act
        const result = getOffset(element);

        // Assert
        expect(result.top).equal(50);
        expect(result.left).to.be.NaN;

        // Clean up
        document.body.removeChild(element);
    });

    // Tests that the function returns the correct offset for an element with no offsetParent.
    it("test_get_offset_with_element_with_no_offsetParent", () => {
        // Arrange
        const element = document.createElement("div");
        element.style.position = "absolute";
        element.style.top = "50px";
        element.style.left = "100px";

        // Act
        const result = getOffset(element);

        // Assert
        expect(result.top).equal(50);
        expect(result.left).equal(100);
    });

    // Tests that the function returns the correct offset for an element with NaN scrollLeft or scrollTop.
    it("test_get_offset_with_element_with_NaN_scrollLeft_or_scrollTop", () => {
        // Arrange
        const element = document.createElement("div");
        element.style.position = "absolute";
        element.style.top = "50px";
        element.style.left = "100px";
        element.scrollLeft = NaN;
        element.scrollTop = NaN;
        document.body.appendChild(element);

        // Act
        const result = getOffset(element);

        // Assert
        expect(result.top).equal(50);
        expect(result.left).equal(100);

        // Clean up
        document.body.removeChild(element);
    });

    // Tests that the function returns the correct offset for an element with negative or non-integer offsetLeft or offsetTop.
    it("test_get_offset_with_element_with_negative_or_non_integer_offsetLeft_or_offsetTop", () => {
        // Arrange
        const element = document.createElement("div");
        element.style.position = "absolute";
        element.style.top = "-50.5px";
        element.style.left = "-100.7px";
        document.body.appendChild(element);

        // Act
        const result = getOffset(element);

        // Assert
        expect(result.top).equal(-50);
        expect(result.left).equal(-100);

        // Clean up
        document.body.removeChild(element);
    });
});

describe("StringUtils class", () => {
    // Tests that ucFirst() method returns a string with the first character in uppercase when provided with a non-empty string.
    it("test_uc_first_with_non_empty_string", () => {
        expect(StringUtils.ucFirst("hello")).equal("Hello");
    });

    // Tests that ucFirst() method returns a string with the first character in uppercase when provided with a string with only one character.
    it("test_uc_first_with_one_character_string", () => {
        expect(StringUtils.ucFirst("h")).equal("H");
    });

    // Tests that ucFirst() method returns an empty string when provided with an empty string.
    it("test_uc_first_with_empty_string", () => {
        expect(StringUtils.ucFirst("")).equal("");
    });

    // Tests that ucFirst() method returns a string with the first character in uppercase when provided with a string with all characters already in uppercase.
    it("test_uc_first_with_all_characters_uppercase", () => {
        expect(StringUtils.ucFirst("HELLO")).equal("HELLO");
    });

    // Tests that ucFirst() method returns a string with the first character in uppercase when provided with a string with leading/trailing whitespaces.
    it("test_uc_first_with_leading_trailing_whitespaces", () => {
        expect(StringUtils.ucFirst("  hello  ")).equal("  hello  ");
    });
});

describe("Validators class", () => {
    // Tests that isColor returns true for undefined.
    it("test_is_color_undefined", () => {
        expect(Validators.isColor(undefined)).equal(true);
    });

    // Tests that isColor returns true for "transparent".
    it("test_is_color_transparent", () => {
        expect(Validators.isColor("transparent")).equal(true);
    });

    // Tests that isUnsignedInt returns false for negative numbers.
    it("test_is_unsigned_int_negative_number", () => {
        expect(Validators.isUnsignedInt("-1")).equal(false);
    });

    // Tests that isColor is case sensitive for hex color codes.
    it("test_is_color_hex_case_insensitive", () => {
        expect(Validators.isColor("#FF0000")).equal(true);
        expect(Validators.isColor("#ff0000")).equal(true);
    });

    // Tests that isColor returns false for invalid hex color codes.
    it("test_is_color_invalid_hex", () => {
        expect(Validators.isColor("#GGGGGG")).equal(false);
    });

    // Tests that isUnsignedInt returns true for positive numbers.
    it("test_is_unsigned_int_positive_number", () => {
        expect(Validators.isUnsignedInt("5")).equal(true);
    });
});

describe("ObjectUtils class", () => {
    let obj: Record<string, unknown>;

    function originalObject() {
        return {
            name: "John",
            age: 30,
            address: {
                street: "123 Main St",
                city: "Anytown",
                country: "USA",
            },
            hobbies: ["reading", "traveling"],
        };
    }

    beforeEach(() => {
        // Arrange
        obj = originalObject();
    });

    // Tests that cloning a simple object with primitive properties returns a deep copy with the same properties and values.
    it("test_clone_primitive_properties", () => {
        // Arrange
        const obj = { name: "John", age: 30 };

        // Act
        const clonedObj = ObjectUtils.clone(obj);

        // Assert
        expect(clonedObj).to.deep.equal(obj);
        expect(clonedObj).to.not.equal(obj);
    });

    // Tests that cloning an object with nested objects and arrays returns a deep copy with the same structure and values.
    it("test_clone_nested_objects_and_arrays", () => {
        // Act
        const clonedObj = ObjectUtils.clone(obj);

        // Assert
        expect(clonedObj).to.deep.equal(obj);
        expect(clonedObj).to.not.equal(obj);
        expect(clonedObj.address).to.not.equal(obj.address);
        expect(clonedObj.hobbies).to.not.equal(obj.hobbies);
    });

    // Tests that cloning an object with non-serializable properties (e.g. functions) returns a deep copy without those properties.
    it("test_clone_non_serializable_properties", () => {
        // Arrange
        obj.sayHello = () => console.log("Hello!");

        // Act
        const clonedObj = ObjectUtils.clone(obj);

        // Assert
        expect(clonedObj).to.deep.equal(originalObject());
    });

    // Tests that cloning an object with large size (e.g. exceeding the maximum JSON size) returns a deep copy without errors or performance issues.
    it("test_clone_large_object", () => {
        // Arrange
        const largeObj: Record<string, Record<string, unknown>> = {};
        for (let i = 0; i < 100000; i++) {
            largeObj[i] = obj;
        }

        // Act
        const clonedObj = ObjectUtils.clone(largeObj);

        // Assert
        expect(clonedObj).to.deep.equal(largeObj);
        expect(clonedObj).to.not.equal(largeObj);
    });

    // Tests that cloning an object with undefined properties returns a deep copy without that properties.
    it("test_clone_undefined_or_null_properties", () => {
        // Arrange
        const obj = {
            name: "John",
            age: null,
            address: undefined,
            hobbies: ["reading", null],
        };

        // Act
        const clonedObj = ObjectUtils.clone(obj);

        // Assert
        expect(clonedObj).to.deep.equal({
            age: null,
            hobbies: ["reading", null],
            name: "John",
        });
    });
});
